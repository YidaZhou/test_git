7.28
What I learned
Today I started learning git and github. In the past year I have been using git, but I never really had the chance to really understand it. Therefore I would say I am pretty much new to it.
The first thing I started out learning was not the commands, but instead about git itself. Git was created Linus, the creator of the Linux system. He initially used BitMover as a version control system for Linux, but as BitMover decided to not provide any more service for Linux, Linus himself made a version control system which became git. Git, unlike the older version control systems, is a distributed system. The old systems were concentrated systems, where everything was stored inside one server. It was really painful for users since they had to upload all their files every time they wanted to commit a version, and also if the server dies, then everyone dies. On the other hand, in a distributed system, every user has his own version storage in his own computer, no more uploading was needed and it became possible to copy the file from one's coworkers if his computer broke. So git immediately became popular.
After knowing about git I started making a repository as I already have git installed. I used the ```git init```command to make the repository and used the ```ls -ah``` command to check the .git file (the repository) was made. Something interesting I noticed was that images, videos and word type files cannot be version controlled by git as they are binary coded. After creating some files, I was able to use ```git status``` to tell whether files have been saved to the repository, which obviously haven't. So I used the ```git add file``` command to add it to the stage, then ```git commit -m "message"``` to commit it and move the version from the stage to the master. After that I was able to use ```git diff file``` to see what I have changed in some of the files since the last commit.
Then I learned about "moving back in time", which is restoring to a previous version. ```git reset --hard commitId``` is the command needed to do so, but first I needed to find the commit id of the version I want to return to. To do this I used the ```git log``` command, which would show me the history of commits and their commit id. I could also use ```HEAD``` as the commit id, it is a pointer to the current master, and so if I want to return to the last version I committed I could use ```HEAD^``` and then ```HEAD^^``` for the next last and so on. If I accidentally to an earlier version, then the log command would no longer be helpful. I could use ```git relog``` to see the history of the commands I entered and their id to help me "return to the future".
The structure of git also caught my eye. First the folder that contains the .git folder is called the working directory and the .git folder is the repository. Inside the repository, there are two most important part which are the stage and the master. When I add a file to the repository, it first goes into the stage which acts like a temporary storage for the version. Then when I commit, git moves everything in the stage into the master, making a new version. Interestingly, git does not save the versions by the files, but instead by the changes, and all the versions, in fact, all exist at the same time just with the ```HEAD``` pointing to what we want to be the master. That is why restoring versions in git is so fast.
I also learned that the ```git checkout -- file``` command restores the version of the working directory back the the one in the stage, this works even if you deleted some files, and also that ```git reset HEAD file``` restores the version of the stage back to the one in the master.
So I then started learning about github. I first needed a ssh key to do so which I already have, But if I didn't have it then I would need to use the ```ssh-keygen -t rsa -C "myEmail@email.com"``` to generate a key in the .ssh file in my user folder. The .pub file in the .ssh folder contains the public key that I would need to use github. Then I created a repository in github and linked it with my local repository following the instructions on github. Then I used the ```git push -u origin master``` command to push my files in the local repository to the github repository and link them. After that, I would only need to use ```git push origin master``` to push. Then if next time I lost my local repository, I could use the ```git clone git@server-name:path/repo-name.git``` command to clone a local repository from the github one.
This is all I learned today.

7.29
I first started learning about branches. A branch is a copy of the master, that the HEAD could also point to. You can add and commit changes to the branch and when you think the branch is good enough, you can merge it with the master. So to make a branch and move to it, I needed the command ```git checkout -b <branch>```. This command consists of two parts, ```git branch <branch>``` that creates the branch (the -b stands for branch) and the ``git checkout <branch>`` that points the HEAD pointer from the master to the branch. Now if I enter ``git branch`` I would be able to see the branch I made together with the master. Then when I feel the branch is ready to merge, I can go to the master by ``git checkout master`` and ``git merge <branch>`` to merge the branch with the master, so then I could delete it with ``git branch -d <branch>``. In the case that both branches have progress, merging then would have conflicts and I would have to solve the conflict manually. Also when merging, by default git uses Fast forward mode, but then in log the branch being merged would not appear. If we use ```git merge --no--ff -m "message" <branch>```, then the other branch merged would show up in the ```log``` history. The ```-m "message"``` is just added to show a message. 
In practice, every developer should have his own branch and everyone should be merging their work to one branch that is not the master. The master should only be merged to from that other branch when a new version (eg. 1.0.12) comes out. 
When developing, we should make a new branch for the bug fixing or adding new features and then delete it after merging. In the case that you need to fix a bug (or simply go to another branch) but you still have uncommitted work in your current branch, you can use ``git stash`` to save your working directory and stage of this branch before you go to another branch. Then when you come back, you can simply ```git stash pop``` and the saved data would be recovered (while the saved data would be deleted). ```pop``` means to first ```apply``` then ```drop```. Also ```git branch -D <branch>``` would delete the branch even if it is not merged, it could sometimes be really useful.
Now branches could be pushed to github. First, we can use ``git remote -v`` to see the information in github. So to push a branch to github, you need ``git push origin <branch>``, but when you are working in a team your teammate might have already made some progress to that branch in github. If so, you will need to first pull the branch and solve the conflict manually. To pull, you need to first link them. If you already have a local branch to link to, then just ```git branch --set-upstream-to=origin/<githubBranch> <localBranch>``` . If not, then you can use ```git checkout -b <localBranch> origin/<githubBranch>``` to create the branch and link it to the github branch in origin. Then you can simply ``git pull`` and pull the branch. The ``git rebase`` command could make the local log history of the committed branches into one single line and make it easier to read, but the changes of each commit would be changed.
Then I started learning about tags. A tag is a single label to one commit so that the commit could be easier found. ``git tag <tag>`` or ``git tag -a <tag> -m "message"`` would add a tag to the current HEAD, but if I know the commit id of a commit then I can also use ```git tag <tag> <commitID>```. Note that tags are always related to one local commit. If the commit is in two branches, then the tag would also be in both. After that I could simply ``git tag`` to see all the tags I added. If I want to delete a tag, then I would enter ``git tag -d <tag>`` and this should be enough if I haven't pushed the tag to github, or else I would have to also need to ```git push origin :refs/tags/tagName``` to delete the tag in the origin. To push a tag to github, ``git push origin <tag>`` would be good, but I can also ``git push origin --tags`` to push all the tags at once. 
I also learned something about the github community.  In github, I can click the fork button to get a copy of the repository in my own github account. Then I can clone, push, and do whatever I want with the repository. If I want to share my changes with the official, I can send a pull request.
Also, if I want git to ingore some files, instead of showing me some annoying warnings whenever I ``git status``, I can create a .gitignore file in the working directory. I would not have to write the file myself but instead I can find everything I need in https://github.com/github/gitignore. Then by adding in some files me myself want git to ignore, the .gitignore file is done. If I want to add an ignored file, I can ```$ git add -f fileName.type``` or if I think the .gitignore file has some problem, I can ```$ git check-ignore -v fileName.type``` to check. 
At last I learned some small tricks about configurations. Here is the list of them:
- ```$ git config --global color.ui true``` would allow git bash to show different colors.
- I can also your own "hotkeys" for some words I don't type a lot. For example, st for status or ci for commit, or even unstage for 'reset HEAD'. All I need to do ```$ git config --global alias.ci commit```. Then every time I want to commit, all I need to do is ```$git ci -m "message"```. If I don't add ``--global`` then this configuration would only work for this git repository.
- global configurations would be stored in a .gitconfig hidden file in the users folder, non-global one would be stored in the .git/config file.
