7.29  
I first started learning about branches. A branch is a copy of the master, that the HEAD could also point to. You can add and commit changes to the branch and when you think the branch is good enough, you can merge it with the master. So to make a branch and move to it, I needed the command ```git checkout -b <branch>```. This command consists of two parts, ```git branch <branch>``` that creates the branch (the -b stands for branch) and the ``git checkout <branch>`` that points the HEAD pointer from the master to the branch. Now if I enter ``git branch`` I would be able to see the branch I made together with the master. Then when I feel the branch is ready to merge, I can go to the master by ``git checkout master`` and ``git merge <branch>`` to merge the branch with the master, so then I could delete it with ``git branch -d <branch>``. In the case that both branches have progress, merging then would have conflicts and I would have to solve the conflict manually. Also when merging, by default git uses Fast forward mode, but then in log the branch being merged would not appear. If we use ```git merge --no--ff -m "message" <branch>```, then the other branch merged would show up in the ```log``` history. The ```-m "message"``` is just added to show a message.  
In practice, every developer should have his own branch and everyone should be merging their work to one branch that is not the master. The master should only be merged to from that other branch when a new version (eg. 1.0.12) comes out.
When developing, we should make a new branch for the bug fixing or adding new features and then delete it after merging. In the case that you need to fix a bug (or simply go to another branch) but you still have uncommitted work in your current branch, you can use ``git stash`` to save your working directory and stage of this branch before you go to another branch. Then when you come back, you can simply ```git stash pop``` and the saved data would be recovered (while the saved data would be deleted). ```pop``` means to first ```apply``` then ```drop```. Also ```git branch -D <branch>``` would delete the branch even if it is not merged, it could sometimes be really useful.  
Now branches could be pushed to github. First, we can use ``git remote -v`` to see the information in github. So to push a branch to github, you need ``git push origin <branch>``, but when you are working in a team your teammate might have already made some progress to that branch in github. If so, you will need to first pull the branch and solve the conflict manually. To pull, you need to first link them. If you already have a local branch to link to, then just ```git branch --set-upstream-to=origin/<githubBranch> <localBranch>``` . If not, then you can use ```git checkout -b <localBranch> origin/<githubBranch>``` to create the branch and link it to the github branch in origin. Then you can simply ``git pull`` and pull the branch. The ``git rebase`` command could make the local log history of the committed branches into one single line and make it easier to read, but the changes of each commit would be changed.  
Then I started learning about tags. A tag is a single label to one commit so that the commit could be easier found. ``git tag <tag>`` or ``git tag -a <tag> -m "message"`` would add a tag to the current HEAD, but if I know the commit id of a commit then I can also use ```git tag <tag> <commitID>```. Note that tags are always related to one local commit. If the commit is in two branches, then the tag would also be in both. After that I could simply ``git tag`` to see all the tags I added. If I want to delete a tag, then I would enter ``git tag -d <tag>`` and this should be enough if I haven't pushed the tag to github, or else I would have to also need to ```git push origin :refs/tags/tagName``` to delete the tag in the origin. To push a tag to github, ``git push origin <tag>`` would be good, but I can also ``git push origin --tags`` to push all the tags at once.  
I also learned something about the github community.  In github, I can click the fork button to get a copy of the repository in my own github account. Then I can clone, push, and do whatever I want with the repository. If I want to share my changes with the official, I can send a pull request.  
Also, if I want git to ingore some files, instead of showing me some annoying warnings whenever I ``git status``, I can create a .gitignore file in the working directory. I would not have to write the file myself but instead I can find everything I need in https://github.com/github/gitignore. Then by adding in some files me myself want git to ignore, the .gitignore file is done. If I want to add an ignored file, I can ```$ git add -f fileName.type``` or if I think the .gitignore file has some problem, I can ```$ git check-ignore -v fileName.type``` to check.  
At last I learned some small tricks about configurations. Here is the list of them:
- ```$ git config --global color.ui true``` would allow git bash to show different colors.  
- I can also your own "hotkeys" for some words I don't type a lot. For example, st for status or ci for commit, or even unstage for 'reset HEAD'. All I need to do ```$ git config --global alias.ci commit```. Then every time I want to commit, all I need to do is ```$git ci -m "message"```. If I don't add ``--global`` then this configuration would only work for this git repository.  
- global configurations would be stored in a .gitconfig hidden file in the users folder, non-global one would be stored in the .git/config file.  
